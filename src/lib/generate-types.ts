import fs from "node:fs";
import path from "node:path";
import { z } from "zod";
import chalk from "chalk";

export interface GenerateTypesOptions {
  schema: z.ZodObject<any>;
  output?: string;           // Output file path (default: "pushenv-env.d.ts")
  addToGitignore?: boolean;  // Add to .gitignore (default: true)
  silent?: boolean;          // Suppress console output (default: false)
}

export interface GenerateTypesResult {
  success: boolean;
  outputPath?: string;
  error?: Error;
}

/**
 * Generate TypeScript type definitions from Zod schema
 * 
 * Creates a .d.ts file with proper types for process.env based on your schema.
 * Supports required/optional fields, enums, and more.
 * 
 * @param options - Generation options
 * @returns Result with output path or error
 * 
 * @example
 * ```typescript
 * import { generateTypes } from 'pushenv';
 * import { z } from 'zod';
 * 
 * generateTypes({
 *   schema: z.object({
 *     PORT: z.coerce.number(),
 *     DATABASE_URL: z.string().url(),
 *     NODE_ENV: z.enum(['development', 'production']),
 *   })
 * });
 * 
 * // Creates pushenv-env.d.ts with proper types!
 * ```
 */
export function generateTypes(options: GenerateTypesOptions): GenerateTypesResult {
  const {
    schema,
    output = "pushenv-env.d.ts",
    addToGitignore = true,
    silent = false,
  } = options;

  try {
    const outputPath = path.resolve(process.cwd(), output);

    if (!silent) {
      console.log(chalk.cyan(`\nüîß Generating TypeScript types...`));
    }

    // Generate type definitions from schema
    const typeDefinitions = generateTypeDefinitionsFromSchema(schema);

    // Write to file
    fs.writeFileSync(outputPath, typeDefinitions, "utf8");

    if (!silent) {
      console.log(chalk.green(`‚úì Generated ${path.basename(outputPath)}`));
    }

    // Add to .gitignore if requested
    if (addToGitignore) {
      addToGitignoreFile(output, silent);
    }

    if (!silent) {
      console.log(chalk.gray(`\nüí° Import this in your code to get typed process.env:`));
      console.log(chalk.gray(`   Add to tsconfig.json: "include": ["${output}"]`));
      console.log();
    }

    return {
      success: true,
      outputPath,
    };

  } catch (error) {
    if (!silent) {
      console.error(chalk.red(`‚ùå Failed to generate types:`), error);
    }

    return {
      success: false,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}

/**
 * Generate TypeScript type definitions from Zod schema
 */
function generateTypeDefinitionsFromSchema(schema: z.ZodObject<any>): string {
  const shape = schema.shape;
  const entries: string[] = [];

  for (const [key, zodType] of Object.entries(shape)) {
    const tsType = zodTypeToTsType(zodType as z.ZodTypeAny);
    const isOptional = zodType instanceof z.ZodOptional || zodType instanceof z.ZodDefault;
    
    // Add JSDoc comment with validation info
    const comment = getJSDocComment(key, zodType as z.ZodTypeAny);
    if (comment) {
      entries.push(comment);
    }
    
    entries.push(`    ${key}${isOptional ? '?' : ''}: ${tsType};`);
  }

  const typeDefinition = `/**
 * Auto-generated TypeScript definitions for environment variables
 * Generated by PushEnv - DO NOT EDIT MANUALLY
 * 
 * This file provides type safety for process.env based on your Zod schema.
 * 
 * @see https://github.com/yourusername/pushenv
 */

declare namespace NodeJS {
  interface ProcessEnv {
${entries.join('\n')}
  }
}

export {};
`;

  return typeDefinition;
}

/**
 * Convert Zod type to TypeScript type string
 */
function zodTypeToTsType(zodType: z.ZodTypeAny): string {
  // Handle optional and default wrappers
  if (zodType instanceof z.ZodOptional || zodType instanceof z.ZodDefault) {
    return zodTypeToTsType((zodType as any)._def.innerType);
  }

  // Handle basic types
  if (zodType instanceof z.ZodString) {
    return 'string';
  }

  if (zodType instanceof z.ZodNumber) {
    return 'number';
  }

  if (zodType instanceof z.ZodBoolean) {
    return 'boolean';
  }

  // Handle enums
  if (zodType instanceof z.ZodEnum) {
    const values = (zodType as any)._def.values as string[];
    return values.map(v => `'${v}'`).join(' | ');
  }

  // Handle literal
  if (zodType instanceof z.ZodLiteral) {
    const value = (zodType as any)._def.value;
    return typeof value === 'string' ? `'${value}'` : String(value);
  }

  // Handle union
  if (zodType instanceof z.ZodUnion) {
    const options = (zodType as any)._def.options as z.ZodTypeAny[];
    return options.map(opt => zodTypeToTsType(opt)).join(' | ');
  }

  // Handle coerce (e.g., z.coerce.number())
  if ((zodType as any)._def?.typeName === 'ZodEffects') {
    const innerType = (zodType as any)._def.schema;
    if (innerType) {
      return zodTypeToTsType(innerType);
    }
  }

  // Handle branded/refined types - use base type
  if ((zodType as any)._def?.innerType) {
    return zodTypeToTsType((zodType as any)._def.innerType);
  }

  // Default to string for unknown types (env vars are strings by default)
  return 'string';
}

/**
 * Generate JSDoc comment for environment variable
 */
function getJSDocComment(key: string, zodType: z.ZodTypeAny): string | null {
  const description = (zodType as any)._def?.description;
  
  if (!description) {
    return null;
  }

  return `    /** ${description} */`;
}

/**
 * Add output file to .gitignore if not already present
 */
function addToGitignoreFile(filename: string, silent: boolean): void {
  const gitignorePath = path.resolve(process.cwd(), ".gitignore");

  try {
    let gitignoreContent = "";

    // Read existing .gitignore if it exists
    if (fs.existsSync(gitignorePath)) {
      gitignoreContent = fs.readFileSync(gitignorePath, "utf8");
    }

    // Check if already in .gitignore
    const lines = gitignoreContent.split("\n");
    const alreadyIgnored = lines.some(line => {
      const trimmed = line.trim();
      return trimmed === filename || trimmed === `/${filename}`;
    });

    if (!alreadyIgnored) {
      // Add comment and entry
      const entry = `\n# Auto-generated TypeScript definitions (PushEnv)\n${filename}\n`;
      
      if (gitignoreContent && !gitignoreContent.endsWith("\n")) {
        gitignoreContent += "\n";
      }
      
      gitignoreContent += entry;
      
      fs.writeFileSync(gitignorePath, gitignoreContent, "utf8");

      if (!silent) {
        console.log(chalk.green(`‚úì Added ${filename} to .gitignore`));
      }
    } else {
      if (!silent) {
        console.log(chalk.gray(`  ${filename} already in .gitignore`));
      }
    }
  } catch (error) {
    // Non-fatal error - just log it
    if (!silent) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Could not update .gitignore:`, error));
    }
  }
}

/**
 * Quick helper to generate types inline (for use with validateOrThrow)
 */
export function generateTypesFromSchema(schema: z.ZodObject<any>, outputPath = "pushenv-env.d.ts"): void {
  generateTypes({ schema, output: outputPath, silent: false });
}

